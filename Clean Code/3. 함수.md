# 함수 

## 작게 만들어라
함수는 작을수록 좋다.   
하나의 함수는 하나의 이야기만을 표현해야하기 때문에 길 필요가 없다.  
중첩 구조가 생기면 안된다.  
들여쓰기도 1~2단을 넘어서면 안 된다.

## 한 가지만 해라.
함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.  
여기서 말하는 한 가지란 하나의 추상화 수준을 의미한다.  
우리가 함수를 만드는 이유는 큰 개념을 한 단계 낮은 추상화 수준으로 여러 단계 나누어 수행하기 위해서이기 때문이다.  
함수가 한 가지만 하는지 판단하는 방법: 함수 내부 구현부에서 의미 있는 이름으로 다른 함수를 추출할 수 있다면, 그 함수는 여러 작업을 한 셈이다. 

## 함수 당 추상화 수준은 하나로.
함수가 확실히 한 가지 작업만 하려면 함수 내 모든 코드의 추상화 수준이 동일해야한다.  
추상화 수준이 높은 예: getHtml();
추상화 수준이 중간인 예: String pagePathName = PathParser.render(pagepaath);
추상화 수준이 낮은 예: .append("\n");  
추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어려워지기 때문이다. 
### 내려가기 규칙
> 추상화 수준을 지키기 위한 방법으로, 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 오도록 한다. 즉 위에서 아래로 프로그램을 읽으면 함수 추상화 단계가 한 단계씩 낮아지게 된다.  
>> Ex) TO 설정 페이지와 해제 페이지를 포함하려면, 설정 페이지를 포함하고, 테스트 페이지 내용을 포함하고, 해제 페이지를 포함한다.  
>>> TO 설정 페이지를 포함하려면, 슈트이면 슈트 설정 페이지를 포함한 후 일반 설정 페이지를 포함한다.  
>>>> TO 슈트 설정 페이지를 포함하려면, 부모 계층에서 "SuiteSetUp" 페이지를 찾아 include 문과 페이지 경로를 추가한다.  
>>>>> TO 부모 계층을 검색하려면, ......


## switch 문
기본적으로 switch 문은 여러가지 일을 처리한다.  
문제점: 
- 함수가 길어진다. 새로운 케이스가 생길 때마다 switch 문에 이어 작성해야한다.
- 한 가지 작업만 수행하지 않는다. 분기마다 수행하는 동작이 다르다.
- SRP(Single Responsibility Principle - 한 클래스는 하나의 책임만 가져야한다.)을 위반한다.
- OCP(Open Closed Principle - 소프트웨어는 확장에는 열려있고 변경에는 닫혀있어야한다.)를 위반한다.

### 결론: 다형성으로 해결한다.
예를 들어 여러 종류의 Employee가 있다면, Employee를 상속하는 세부 직원 클래스를 만들고 해당 인스턴스를 Employee로 받아 사용하도록한다.

## 서술적인 이름을 사용하라.
서술적인 이름이 코드를 읽고 이해하기 훨씬 쉽다.  
좋은 코드란 읽으면서 짐작했던 기능을 그대로 수행하는 코드이다.  
함수는 특정 기능을 수행해야하고, 기능을 잘 설명할수 있는 단어는 서술형이 적절하다.

## Parameter
함수의 인수 갯수는 적을수록 좋다.  
0, 1, 2개 이하가 적절하고 3개는 가능한 피하고, 4개는 특별한 사유가 있어도 사용하지 말도록하자.  
|Bad|Good|
|---|---|
|includeSetupPageInto(newPageContent)|includeSetupPage()|

어떤게 더 이해하기 쉬운가  

테스트 관점에서도 유효한 인수를 넣고 가능한 모든 조합을 구성하며 테스트하기가 힘들다.  

또한 출력 인수를 사용하지 말라. 대개 함수에서 인수로 결과를 받으리라 기대하지 않기 때문이다.
|Bad|Good|
|---|---|
|void transform(StringBuffer out) | String Buffer transform(StringBuffer in)|

## 플래그 인수
함수의 인자로 boolean 값을 넘기지 말라. 대놓고 함수가 한꺼번에 여러 가지 일을 처리한다고 말하는 셈이다. 대신 함수를 여러개 만들자.

## 이항 함수
인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다. 
|Bad|Good|Better|
|---|---|---|
|writeField(outputStream, name) | writeField(name)|outputStream.writeField(name)|
|||멤버변수로 만들어 인수로 넘기지 않는다.
Bad 케이스의 첫 번째 인수를 보고 잠시 멈칫하다가 무시해도 된다는걸 깨닫고 넘어간다. 하지만 코드에서 무시해도 될 부분은 없다. 모두 의미가 있어야 한다. 이렇게 무시한 코드는 결국 잘못 파생된 결과를 낳는다.

## 인수가 늘어나면 클래스 변수로 선언할 수 있는지 검토한다.
|Bad|Good|
|---|---|
|Circle makeCircle(double x, double y, double radius); |Circle makeCircle(Point center, double radius);|
x, y 값을 Point 객체로 묶음으로서 인수를 줄였다.

## 인수 목록
인수 갯수가 가변적이라면 List 형 인수로 취급한다.
|Bad|Good|
|---|---|
|public String format(String format, String name, String hours);|public String format(String format, Object... args)|

## 함수 이름은 동사로, 인수는 명사(목적어)로 짓는다.
|Good|Better|
|---|---|
|write(name)|writeField(name)|
|assertEquals(expected, actual) |assertExpectedEqualsActual(expected, actual)|

## 부수 효과를 일으키지 마라.
함수는 한 가지의 일만 해야한다는 규칙에 위배된다. 함수 이름에서 의도한 동작을 수행하며 한 두개 동작을 더 한다면 누군가 함수를 가져다 쓸때 자기도 모르는 부수적인 동작이 수행된다.
```java
public boolean checkPassword(String userName, String password){
    if("Valid Password".equals(password)){
        Session.initialize();
        return true;
    }
    return false;
}
```
비밀번호를 확인하리라 생각했는데 세션을 초기화하는 코드도 들어가있어 원치않게 세션을 초기화 하는 일이 생길 수 있다.

## 명령과 조회를 분리하라.
```java
public boolean set(String attribute, String value)

if(set("userName", "unclebob"))

```
위 예시에서 함수 이름 set은 동사이지만 if문 안에서는 형용사로 느껴진다. 
의도: attribute의 값을 value로 설정하라
결과: attribute가 value로 설정되어 있다면 true, 아니면 false를 반환하나보다.

## 오류 코드보다 예외를 사용하라.
오류 처리를 if문으로 구현해서 가독성이 매우 떨어진다.   
try/catch가 담긴 함수도 역시 오류 처리만 담당하도록 try 내부의 모든 구현을 하나의 다른 함수로 만들어 주는게 적절하다.  
종종 오류 에러 코드를 만들기 위해 enum 클래스를 구현하는 경우가 있는데 이런 오류 코드를 구현하는 대신 오류 처리가 필요한 부분에서 try-catch를 사용하자.
<table>
 <tr>
  <th>Bad</th>
  <th>Good</th>
  <th>Better</th>
</tr>
<tr>
 <td>

```java
if (deletePge(page) ==E_OK){
    if(registry.deleteReference(page.name) == E_OK){
        if (configKeys.deleteKey(page.name.makeKey()) == E_OK) {
            logger.log("pageDeleted");
        } else {
            logger.log("configKey not deleted");
        }
    } else {
        logger.log("deleteReference from registry failed");
    }
} else {
    logger.log("delete failed");
    return E_ERROR;
}
```
</td>
<td>

```java
try {
    deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deleteKey(page.name.makeKey());
} catch (Exception e) {
    logger.log(e.getMessage());
}
```
</td>
<td>

```java
public void delete(Page page){
    try {
        deletePageAndAllReferences(page);
    } catch (Exception e) {
        logError(e);
    }
}

public void deletePageAndAllReferences(Page page) throws Exception {
    deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deleteKey(page.name.makeKey());
}

private void logError(Exception e) {
    logger.log(e.getMessage());
}
```
</td>
</table>

## 반복되는 코드는 함수로 재사용하라. 절대 코드를 반복하지 마라.   
알고리즘이 변하면 중복되는 모든 부분을 손봐야 하고 어느 한 곳이라도 빠뜨리면 오류가 발생하게 된다. 동일한 역할을 하는 코드는 함수로 만들어 사용해야한다.

### 구조적 프로그래밍
함수 내 모든 블록에서 입구와 출구는 하나여야 한다.
- return 문은 하나여야 한다. 
- loop 안에서 break나 continue를 사용하지 않는다.
단, 함수가 작다면 return, break, continue를 여러 차례 사용해도 괜찮지만 큰 함수에서는 사용을 지양해야한다.

## 결론
프로그램이 아니라 이야기로 생각하자. 
