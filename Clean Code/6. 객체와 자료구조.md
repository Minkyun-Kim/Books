# 객체와 자료구조


## 객체와 자료구조의 정의

### 객체
- 데이터를 숨기고 데이터를 활용해 동작을 수행하는 추상화 수준이 높은 `함수`를 공개한다.
```java
class Circle implements Shape {
    private double radius; // 멤버변수는 private으로 비공개
    private Point center;

    public double area() { // 멤버변수를 이용해 특정 동작을 수행하는 함수를 제공
        return radius * radius * 3.14;
    }
}

class Vehicle {

    public double getPercentFuelRemaining() {
        ...;
    }
}
```

### 자료구조
- 데이터 자체를 공개한다. 직접 접근이 허용되며 데이터를 활용할 추가 클래스가 필요하다.
- Getter, Setter만 포함한 클래스 역시 자료구조로 본다. (DTO)
```java
class Circle {
    public double radius; // public 멤버변수 선언으로 직접 접근 허용
    public Point center;
}

class Geometry { // Circle 자료구조를 활용할 추가 클래스

    public double area(Object shape) { // 추가 클래스에서 자료구조를 활용한 동작 수행
        if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            return circle.radius * circle.radius * 3.14;
        }
        return ...;
    }
}
```

## 객체와 자료구조의 장/단점

### 객체

**장점** 
> 새 클래스를 추가해도 기존 함수에 아무런 영향을 미치지 않는다.  

<table>
 <tr>
  <th>Before</th>
  <th>After</th>
 </tr>
 <tr>
  <td>

```java
class Circle implements Shape {
    private double radius;
    private Point center;

    public double area() {
        return radius * radius * 3.14;
    }
}
```
  </td>
  <td>

 ```java
 class Circle implements Shape {
    private double radius;
    private Point center;

    public double area() {
        return radius * radius * 3.14;
    }
}

class Square implements Shape {
    private double width;
    private double height;

    public double area() {
        return width * height;
    }
}
 ```
  </td>
 </tr>
</table>

**단점**
> 새 함수를 추가해야 한다면 모든 클래스를 수정해야 한다. 

<table>
 <tr>
  <th>Before</th>
  <th>After</th>
 </tr>
 <tr>
  <td>

  ```java
   class Circle implements Shape {
    private double radius;
    private Point center;

    public double area() {
        return radius * radius * 3.14;
    }
}

class Square implements Shape {
    private double width;
    private double height;

    public double area() {
        return width * height;
    }
}
  ```
  </td>
  <td>

  ```java
   class Circle implements Shape {
    private double radius;
    private Point center;

    public double area() {
        return radius * radius * 3.14;
    }
    
    public double length() {
        return ...;
    }
}

class Square implements Shape {
    private double width;
    private double height;

    public double area() {
        return width * height;
    }

    public double length() {
        return ...;
    }
}
  ```
  </td>
 <tr>
</table>

### 자료구조

**장점**
> 새 함수를 추가하기 위해 기존 자료구조를 수정하지 않아도 된다.

<table>
 <tr>
  <td>Before</td>
  <td>After</td>
 </tr>
 <tr>
  <td>

  ```java
  class Circle {
      public double radius;
      public Point center;
  }

  class Geometry {
      public double area(Object object) {
          return ...;
      }
  }
  ```
  </td>
  <td>

  ```java
  class Circle {
      public double radius;
      public Point center;
  }
  
  class Square {
      public double width;
      public double height;
  }

  class Geometry {
      public double area(Object object) {
          return ...;
      }
  }
  ```
  </td>
</table>

**단점**
> 새 자료구조가 추가 되면 모든 함수를 수정해야 한다.
<table>
 <tr>
  <td>Before</td>
  <td>After</td>
 </tr>
 <tr>
  <td>

  ```java
  class Circle {
      public double radius;
      public Point center;
  }

  class Geometry {
      public double area(Object object) {
          if (object instanceof Circle) {
              return ...;
          }
          return ...;
      }
      public double length(Object object) {
          if(object instanceof Circle) {
              return ...;
          }
          return ...;
      }
  }
  ```
  </td>
  <td>

  ```java
  class Circle {
      public double radius;
      public Point center;
  }
  
  class Square {
      public double width;
      public double height;
  }
  
  class Geometry {
      public double area(Object object) {
          if (object instanceof Circle) {
              return ...;
          } else if (object instanceof Square){
              return ...;
          }
          return ...;
      }
      public double length(Object object) {
          if(object instanceof Circle) {
              return ...;
          } else if (object instanceof Square){
              return ...;
          }
          return ...;
      }
  }
  ```
  </td>
</table>

### 결론
> 새 클래스를 추가하는 일이 잦다면 객체 지향 기법을,  
> 새 함수를 추가하는 일이 잦다면 자료구조를 이용한 절차 지향 기법을 사용하자.


## 디미터의 법칙
모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다.  
-> 특정 함수를 사용하기 위해 객체 속의 객체 속의 객체 속의 객체를 호출하지 말라.  
-> 객체 호출 depth를 늘리지 말라.
- 메소드 인수로 넘어온 객체의 메소드 까지만 사용할 것.
- 메소드 내에서 생성한 객체의 메소드 까지만 사용할 것.
- 클래스 멤버 변수 객체의 메소드 까지만 사용할 것.
- 클래스 내부 메소드 까지만 사용할 것.

### Train wreck
메소드 호출 depth를 늘리는 train wreck 사용은 자제한다.  
여러 depth의 호출이 필요한 경우라면 데이터의 직접 접근을 위해 만들어진 자료구조를 사용하는게 적합하다.
```java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); // X
final String outputDit = ctxt.options.scratchDir.absolutePath // O
```

**더 좋은 방법**  
객체에게는 무언가 수행하라고 시켜야 한다. 데이터를 요구하면 안된다.
위 예제에서 절대 경로를 받는 이유가 절대 경로를 이용해 해당 경로에 파일을 만들어야하기 때문이라면 ctxt 객체에 파일을 만드는 동작을 수행하는 메소드를 구현하도록 해야한다.
```java
File newFile = ctxt.createNewFileOnAbsolutePath();
```

## 정리
1. 객체와 자료구조의 차이
   - 새 자료형(클래스)을 추가하는 일이 잦다면 객체 지향 기법을,
   - 새 동작(메소드)을 추가하는 일이 잦다면 자료구조를 이용한 절차지향 기법을 사용하자.

2. 추상화 하라
   - Getter 함수로 데이터를 가져오지 말고 데이터가 필요한 일을 수행하는 메소드를 호출하자.



















